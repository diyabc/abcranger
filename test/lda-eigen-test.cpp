#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>

#include <iostream>
#include <Eigen/Dense>
#include "lda-eigen.hpp"

using namespace Eigen;
using namespace std;

std::vector<double> S{
    5.1, 3.5, 1.4, 0.2,
    4.9, 3.0, 1.4, 0.2,
    4.7, 3.2, 1.3, 0.2,
    4.6, 3.1, 1.5, 0.2,
    5.0, 3.6, 1.4, 0.2,
    5.4, 3.9, 1.7, 0.4,
    4.6, 3.4, 1.4, 0.3,
    5.0, 3.4, 1.5, 0.2,
    4.4, 2.9, 1.4, 0.2,
    4.9, 3.1, 1.5, 0.1,
    5.4, 3.7, 1.5, 0.2,
    4.8, 3.4, 1.6, 0.2,
    4.8, 3.0, 1.4, 0.1,
    4.3, 3.0, 1.1, 0.1,
    5.8, 4.0, 1.2, 0.2,
    5.7, 4.4, 1.5, 0.4,
    5.4, 3.9, 1.3, 0.4,
    5.1, 3.5, 1.4, 0.3,
    5.7, 3.8, 1.7, 0.3,
    5.1, 3.8, 1.5, 0.3,
    5.4, 3.4, 1.7, 0.2,
    5.1, 3.7, 1.5, 0.4,
    4.6, 3.6, 1.0, 0.2,
    5.1, 3.3, 1.7, 0.5,
    4.8, 3.4, 1.9, 0.2,
    5.0, 3.0, 1.6, 0.2,
    5.0, 3.4, 1.6, 0.4,
    5.2, 3.5, 1.5, 0.2,
    5.2, 3.4, 1.4, 0.2,
    4.7, 3.2, 1.6, 0.2,
    4.8, 3.1, 1.6, 0.2,
    5.4, 3.4, 1.5, 0.4,
    5.2, 4.1, 1.5, 0.1,
    5.5, 4.2, 1.4, 0.2,
    4.9, 3.1, 1.5, 0.2,
    5.0, 3.2, 1.2, 0.2,
    5.5, 3.5, 1.3, 0.2,
    4.9, 3.6, 1.4, 0.1,
    4.4, 3.0, 1.3, 0.2,
    5.1, 3.4, 1.5, 0.2,
    5.0, 3.5, 1.3, 0.3,
    4.5, 2.3, 1.3, 0.3,
    4.4, 3.2, 1.3, 0.2,
    5.0, 3.5, 1.6, 0.6,
    5.1, 3.8, 1.9, 0.4,
    4.8, 3.0, 1.4, 0.3,
    5.1, 3.8, 1.6, 0.2,
    4.6, 3.2, 1.4, 0.2,
    5.3, 3.7, 1.5, 0.2,
    5.0, 3.3, 1.4, 0.2};

std::vector<double> C{
    7.0, 3.2, 4.7, 1.4,
    6.4, 3.2, 4.5, 1.5,
    6.9, 3.1, 4.9, 1.5,
    5.5, 2.3, 4.0, 1.3,
    6.5, 2.8, 4.6, 1.5,
    5.7, 2.8, 4.5, 1.3,
    6.3, 3.3, 4.7, 1.6,
    4.9, 2.4, 3.3, 1.0,
    6.6, 2.9, 4.6, 1.3,
    5.2, 2.7, 3.9, 1.4,
    5.0, 2.0, 3.5, 1.0,
    5.9, 3.0, 4.2, 1.5,
    6.0, 2.2, 4.0, 1.0,
    6.1, 2.9, 4.7, 1.4,
    5.6, 2.9, 3.6, 1.3,
    6.7, 3.1, 4.4, 1.4,
    5.6, 3.0, 4.5, 1.5,
    5.8, 2.7, 4.1, 1.0,
    6.2, 2.2, 4.5, 1.5,
    5.6, 2.5, 3.9, 1.1,
    5.9, 3.2, 4.8, 1.8,
    6.1, 2.8, 4.0, 1.3,
    6.3, 2.5, 4.9, 1.5,
    6.1, 2.8, 4.7, 1.2,
    6.4, 2.9, 4.3, 1.3,
    6.6, 3.0, 4.4, 1.4,
    6.8, 2.8, 4.8, 1.4,
    6.7, 3.0, 5.0, 1.7,
    6.0, 2.9, 4.5, 1.5,
    5.7, 2.6, 3.5, 1.0,
    5.5, 2.4, 3.8, 1.1,
    5.5, 2.4, 3.7, 1.0,
    5.8, 2.7, 3.9, 1.2,
    6.0, 2.7, 5.1, 1.6,
    5.4, 3.0, 4.5, 1.5,
    6.0, 3.4, 4.5, 1.6,
    6.7, 3.1, 4.7, 1.5,
    6.3, 2.3, 4.4, 1.3,
    5.6, 3.0, 4.1, 1.3,
    5.5, 2.5, 4.0, 1.3,
    5.5, 2.6, 4.4, 1.2,
    6.1, 3.0, 4.6, 1.4,
    5.8, 2.6, 4.0, 1.2,
    5.0, 2.3, 3.3, 1.0,
    5.6, 2.7, 4.2, 1.3,
    5.7, 3.0, 4.2, 1.2,
    5.7, 2.9, 4.2, 1.3,
    6.2, 2.9, 4.3, 1.3,
    5.1, 2.5, 3.0, 1.1,
    5.7, 2.8, 4.1, 1.3};

std::vector<double> V{
    6.3, 3.3, 6.0, 2.5,
    5.8, 2.7, 5.1, 1.9,
    7.1, 3.0, 5.9, 2.1,
    6.3, 2.9, 5.6, 1.8,
    6.5, 3.0, 5.8, 2.2,
    7.6, 3.0, 6.6, 2.1,
    4.9, 2.5, 4.5, 1.7,
    7.3, 2.9, 6.3, 1.8,
    6.7, 2.5, 5.8, 1.8,
    7.2, 3.6, 6.1, 2.5,
    6.5, 3.2, 5.1, 2.0,
    6.4, 2.7, 5.3, 1.9,
    6.8, 3.0, 5.5, 2.1,
    5.7, 2.5, 5.0, 2.0,
    5.8, 2.8, 5.1, 2.4,
    6.4, 3.2, 5.3, 2.3,
    6.5, 3.0, 5.5, 1.8,
    7.7, 3.8, 6.7, 2.2,
    7.7, 2.6, 6.9, 2.3,
    6.0, 2.2, 5.0, 1.5,
    6.9, 3.2, 5.7, 2.3,
    5.6, 2.8, 4.9, 2.0,
    7.7, 2.8, 6.7, 2.0,
    6.3, 2.7, 4.9, 1.8,
    6.7, 3.3, 5.7, 2.1,
    7.2, 3.2, 6.0, 1.8,
    6.2, 2.8, 4.8, 1.8,
    6.1, 3.0, 4.9, 1.8,
    6.4, 2.8, 5.6, 2.1,
    7.2, 3.0, 5.8, 1.6,
    7.4, 2.8, 6.1, 1.9,
    7.9, 3.8, 6.4, 2.0,
    6.4, 2.8, 5.6, 2.2,
    6.3, 2.8, 5.1, 1.5,
    6.1, 2.6, 5.6, 1.4,
    7.7, 3.0, 6.1, 2.3,
    6.3, 3.4, 5.6, 2.4,
    6.4, 3.1, 5.5, 1.8,
    6.0, 3.0, 4.8, 1.8,
    6.9, 3.1, 5.4, 2.1,
    6.7, 3.1, 5.6, 2.4,
    6.9, 3.1, 5.1, 2.3,
    5.8, 2.7, 5.1, 1.9,
    6.8, 3.2, 5.9, 2.3,
    6.7, 3.3, 5.7, 2.5,
    6.7, 3.0, 5.2, 2.3,
    6.3, 2.5, 5.0, 1.9,
    6.5, 3.0, 5.2, 2.0,
    6.2, 3.4, 5.4, 2.3,
    5.9, 3.0, 5.1, 1.8};


TEST_CASE("LDA with Eigen")
{
    const size_t K = 3;
    const size_t p = 4;
    const size_t n = (S.size() + C.size() + V.size()) / p;
    Matrix<size_t,-1,1> y(n);
    MatrixXd x(n,p);
    // S
    for (auto i = 0; i < (S.size()) / p; i++)
    {
        y[i] = 0;
        for (auto j = 0; j < p; j++)
            x(i, j) = S[i * p + j];
    }
    for (auto i = 0; i < (C.size()) / p; i++)
    {
        auto ii = (S.size() / p) + i;
        y[ii] = 1;
        for (auto j = 0; j < p; j++)
            x(ii, j) = C[i * p + j];
    }
    for (auto i = 0; i < (V.size()) / p; i++)
    {
        auto ii = (S.size() + C.size()) / p + i;
        y[ii] = 2;
        for (auto j = 0; j < p; j++)
            x(ii, j) = V[i * p + j];
    }
    MatrixXd Ld;
    lda(x,y,Ld);

    MatrixXd LdMass(p,K-1);
    LdMass << 
        //  0.8293776,  0.02410215,
        //  1.5344731,  2.16452123,
        // -2.2012117, -0.93192121,
        // -2.8104603,  2.83918785; 
        -0.82937764226600674,  0.024102148876954166,
        -1.53447306770001091,  2.164521234658435489,
         2.20121165556177356, -0.931921210029371894,
         2.81046030884310172,  2.839187852982734128;

    auto LdPlus = Ld + LdMass;
    auto LdMinus = Ld - LdMass;
    for(auto c = 0; c < K - 1; c++) {
        CHECK(std::min(LdPlus.col(c).lpNorm<Infinity>(),LdMinus.col(c).lpNorm<Infinity>()) == Approx(0.0).margin(1e-13));
    }
}

TEST_CASE("LDA with Eigen and constant variable")
{
    const size_t K = 3;
    const size_t p = 4;
    const size_t n = (S.size() + C.size() + V.size()) / p;
    Matrix<size_t,-1,1> y(n);
    MatrixXd x(n,p+1);
    // S
    for (auto i = 0; i < (S.size()) / p; i++)
    {
        y[i] = 0;
        for (auto j = 0; j < p; j++)
            x(i, j) = S[i * p + j];
    }
    for (auto i = 0; i < (C.size()) / p; i++)
    {
        auto ii = (S.size() / p) + i;
        y[ii] = 1;
        for (auto j = 0; j < p; j++)
            x(ii, j) = C[i * p + j];
    }
    for (auto i = 0; i < (V.size()) / p; i++)
    {
        auto ii = (S.size() + C.size()) / p + i;
        y[ii] = 2;
        for (auto j = 0; j < p; j++)
            x(ii, j) = V[i * p + j];
    }
    for(auto i = 0; i < n; i++) {
        x(i,p) = x(i,2);
        x(i,2) = y[i];
    }
    MatrixXd Ld;
    lda(x,y,Ld);

    MatrixXd LdMass(p,K-1);
    LdMass << 
        //  0.8293776,  0.02410215,
        //  1.5344731,  2.16452123,
        // -2.2012117, -0.93192121,
        // -2.8104603,  2.83918785; 
        -0.82937764226600674,  0.024102148876954166,
        -1.53447306770001091,  2.164521234658435489,
         2.81046030884310172,  2.839187852982734128,
         2.20121165556177356, -0.931921210029371894;

    auto LdPlus = Ld + LdMass;
    auto LdMinus = Ld - LdMass;
    for(auto c = 0; c < K - 1; c++) {
        CHECK(std::min(LdPlus.col(c).lpNorm<Infinity>(),LdMinus.col(c).lpNorm<Infinity>()) == Approx(0.0).margin(1e-13));
    }
}
